<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <script src="../src/utils.js"></script>
</head>
<body>
    <canvas id="canvas" width="800px" height="400px"></canvas>
</body>
<script>
    const canvas = document.getElementById('canvas');
    canvas.width = 800;
    canvas.height = 400;
    const gl = canvas.getContext( 'webgl2', { antialias: true } );

    const canvasWidth = canvas.width;
    const canvasHeight = canvas.height;


    // -- Init program
    var drawMULFBOProgram = createProgram(gl, getMULFBOVSHADER(), getMULFBOFSHADER());
    var multipleOutputUniformMvpLocation = gl.getUniformLocation(drawMULFBOProgram, 'mvp');
    
    var drawProgram = createProgram(gl, getVSHADER(), getFSHADER());
    var layerUniformMvpLocation = gl.getUniformLocation(drawProgram, 'mvp');
    var layerUniformDiffuseLocation = gl.getUniformLocation(drawProgram, 'diffuse');
    var layerUniformLayerLocation = gl.getUniformLocation(drawProgram, 'layer');

    var drawUniformColor1Location = gl.getUniformLocation(drawProgram, 'color1Map');
    var drawUniformColor2Location = gl.getUniformLocation(drawProgram, 'color2Map');
    

    var mvpLocation = gl.getUniformLocation(drawProgram, 'MVP');

    // -- Init buffers

    var positions = new Float32Array([
        -1.0, -1.0,
            1.0, -1.0,
            1.0,  1.0,
            1.0,  1.0,
        -1.0,  1.0,
        -1.0, -1.0
    ]);

    var vertexPosBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexPosBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
    gl.bindBuffer(gl.ARRAY_BUFFER, null);

    var texcoords = new Float32Array([
        0.0, 0.0,
        1.0, 0.0,
        1.0, 1.0,
        1.0, 1.0,
        0.0, 1.0,
        0.0, 0.0
    ]);

    var vertexTexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexTexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, texcoords, gl.STATIC_DRAW);
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
    
     // -- Initialize vertex array
    // fbo multiple output
    var multipleOutputVertexArray = gl.createVertexArray();
    gl.bindVertexArray(multipleOutputVertexArray);

    var multipleOutputVertexPosLocation = 0; // set with GLSL layout qualifier
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexPosBuffer);
    gl.vertexAttribPointer(multipleOutputVertexPosLocation, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(multipleOutputVertexPosLocation);
    gl.bindBuffer(gl.ARRAY_BUFFER, null);

    gl.bindVertexArray(null);
   

    // draw screen
   
    var layerVertexArray = gl.createVertexArray();
    gl.bindVertexArray(layerVertexArray);

    var layerVertexPosLocation = 0; // set with GLSL layout qualifier
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexPosBuffer);
    gl.vertexAttribPointer(layerVertexPosLocation, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(layerVertexPosLocation);
    gl.bindBuffer(gl.ARRAY_BUFFER, null);

    var layerVertexTexLocation = 4; // set with GLSL layout qualifier
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexTexBuffer);
    gl.vertexAttribPointer(layerVertexTexLocation, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(layerVertexTexLocation);
    gl.bindBuffer(gl.ARRAY_BUFFER, null);

    gl.bindVertexArray(null);
  
    // -- Initialize texture

    gl.activeTexture(gl.TEXTURE0);
    var texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D_ARRAY, texture);
    gl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_BASE_LEVEL, 0);
    gl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_MAX_LEVEL, 0);
    gl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

    var w = 16; // texture size
    var h = 16;

    gl.texImage3D(gl.TEXTURE_2D_ARRAY,
        0,
        gl.RGB8,
        w,
        h,
        3,//depth
        0,
        gl.RGB,
        gl.UNSIGNED_BYTE,
        null);

    // -- Initialize frame buffer

    var frameBuffer = gl.createFramebuffer();
    gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, frameBuffer);

    var redDrawBufferPos = gl.COLOR_ATTACHMENT0;
    var greenDrawBufferPos = gl.COLOR_ATTACHMENT1;
    var blueDrawBufferPos = gl.COLOR_ATTACHMENT2;

    gl.framebufferTextureLayer(gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, texture, 0, 0);
    gl.framebufferTextureLayer(gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT1, texture, 0, 1);
    gl.framebufferTextureLayer(gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT2, texture, 0, 2);

    var status = gl.checkFramebufferStatus(gl.DRAW_FRAMEBUFFER);
    if (status != gl.FRAMEBUFFER_COMPLETE) {
        console.warn('fbo bind failed!');
    }

    gl.drawBuffers([
        redDrawBufferPos,
        greenDrawBufferPos,
        blueDrawBufferPos
    ]);

    gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);

  
    // -- Render
    // Clear color buffer
    gl.clearColor(0.0, 0.0, 0.0, 1.0);
    gl.clear(gl.COLOR_BUFFER_BIT);

    // Pass 1 draw into fbo (texture array)
    gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, frameBuffer);

    // Bind program
    gl.useProgram(drawMULFBOProgram);

    var matrix = new Float32Array([
        1.0, 0.0, 0.0, 0.0,
        0.0, 1.0, 0.0, 0.0,
        0.0, 0.0, 1.0, 0.0,
        0.0, 0.0, 0.0, 1.0
    ]);
    gl.uniformMatrix4fv(multipleOutputUniformMvpLocation, false, matrix);
    gl.bindVertexArray(multipleOutputVertexArray);
    gl.viewport(0, 0, w, h);
    gl.drawArrays(gl.TRIANGLES, 0, 6);

    // Pass 2 draw into screen
    gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null); // bind screen framebuffer

    // Bind program
    gl.useProgram(drawProgram);

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D_ARRAY, texture);

    gl.uniformMatrix4fv(layerUniformMvpLocation, false, matrix);
    gl.uniform1i(layerUniformDiffuseLocation, 0); // 为 sampler2DArray diffuse 指定 texture array 纹理

    
    gl.bindVertexArray(layerVertexArray);

    // 在左上角绘制 texture array 中第一张纹理的采样内容
    gl.viewport(0, canvasHeight/2, canvasWidth/2, canvasHeight/2);
    gl.uniform1i(layerUniformLayerLocation, 0); // 为 int layer 传值 0，用于在 shader 中指定 texture array 的纹理序号
    gl.drawArrays(gl.TRIANGLES, 0, 6);

    // 在右上角绘制 texture array 中第二张纹理的采样内容
    gl.viewport(canvasWidth/2, canvasHeight/2, canvasWidth/2, canvasHeight/2);
    gl.uniform1i(layerUniformLayerLocation, 1);
    gl.drawArrays(gl.TRIANGLES, 0, 6);

    // 在左下角绘制 texture array 中第三张纹理的采样内容
    gl.viewport(0, 0, canvasWidth/2, canvasHeight/2);
    gl.uniform1i(layerUniformLayerLocation, 2);
    gl.drawArrays(gl.TRIANGLES, 0, 6);

    // readPixels
    var dataArray = new Uint8Array( w * h * 4 * 3 ); // 纹理大小为 w * h，读取的格式为  gl.RGBA，一共有三张纹理

    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, frameBuffer); // 将 framebuffer 重新绑定为 gl.READ_FRAMEBUFFER

    gl.readBuffer(gl.COLOR_ATTACHMENT0);
    gl.readPixels(0, 0, w, h, gl.RGBA, gl.UNSIGNED_BYTE, dataArray, 0);

    // Clean up
 

function getMULFBOVSHADER () {
    return `#version 300 es
        #define POSITION_LOCATION 0

        precision highp float;
        precision highp int;

        uniform mat4 mvp;

        layout(location = POSITION_LOCATION) in vec2 position;

        void main()
        {
            gl_Position = mvp * vec4(position, 0.0, 1.0);
        }
    `
}

function getMULFBOFSHADER () {
    return `#version 300 es

        precision highp float;
        precision highp int;

        layout(location = 0) out vec4 red;
        layout(location = 1) out vec4 green;
        layout(location = 2) out vec4 blue;

        void main()
        {
            red = vec4(1.0, 0.0, 0.0, 1.0);
            green = vec4(0.0, 1.0, 0.0, 1.0);
            blue = vec4(0.0, 0.0, 1.0, 1.0);
        }`
}

function getVSHADER () {
    return `#version 300 es
        #define POSITION_LOCATION 0
        #define TEXCOORD_LOCATION 4

        precision highp float;
        precision highp int;

        uniform mat4 mvp;

        layout(location = POSITION_LOCATION) in vec2 position;
        layout(location = TEXCOORD_LOCATION) in vec2 textureCoordinates;

        out vec2 v_st;

        void main()
        {
            v_st = textureCoordinates;
            gl_Position = mvp * vec4(position, 0.0, 1.0);
        }
    `
}

function getFSHADER () {
    return `#version 300 es

    precision highp float;
    precision highp int;
    precision lowp sampler2DArray;

    uniform sampler2DArray diffuse;
    uniform int layer;

    in vec2 v_st;

    out vec4 color;

    void main()
    {
        color = texture(diffuse, vec3(v_st, float(layer)));
    }`
}

</script>

</html>
