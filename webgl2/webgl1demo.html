<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        #canvas{
            display: block;
            margin: 0 auto;
            border: 1px solid;
        }
    </style>
    <script src="../src/cuon-matrix.js"></script>
</head>
<body>
    <canvas id="canvas" width="800px" height="600px"></canvas>
</body>
<script>
    const canvas = document.getElementById('canvas');
    canvas.width = 800
    canvas.height = 600
    const gl = canvas.getContext('webgl');

    const vertices = new Float32Array([
            0.0,    0.5,
            -0.5,   -0.5,
            0.5,    -0.5
    ]) // 点的坐标数组 类型化数组
    const colors = new Float32Array([
        1.0,0.0,0.0,
        0.0,1.0,0.0,
        0.0,0.0,1.0
    ])
    const FSIZE = vertices.BYTES_PER_ELEMENT
    

    var vertexShader = loadShader(gl, gl.VERTEX_SHADER, getVSHADER()); // 创建顶点着色器对象
    var fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, getFSHADER()); // 创建片元着色器对象

    var program = gl.createProgram(); // 创建程序对象 
    gl.attachShader(program, vertexShader); // 绑定着色器对象
    gl.attachShader(program, fragmentShader);

    gl.linkProgram(program); // 链接着色器对象

    gl.useProgram(program); // 上下文对象绑定程序对象 

    
    gl.clearColor(0.0, 1.0, 1.0, 1.0)
    gl.clear(gl.COLOR_BUFFER_BIT)

    
    // set attribute a_Position
    var a_Position = gl.getAttribLocation(program, "a_Position")
    var vertexBuffer = gl.createBuffer()
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer)
    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW)
    gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 0,0)
    gl.enableVertexAttribArray(a_Position)
    
   
    var a_Color = gl.getAttribLocation(program, "a_Color")
    var colorsBuffer = gl.createBuffer()
    gl.bindBuffer(gl.ARRAY_BUFFER,colorsBuffer)
    gl.bufferData(gl.ARRAY_BUFFER,colors,gl.STATIC_DRAW)
    gl.vertexAttribPointer(a_Color,3,gl.FLOAT,false,0,0)
    gl.enableVertexAttribArray(a_Color)



    // set unifrom
    var rotMatrix = new Matrix4()
    rotMatrix.setRotate(90.0, 0, 0, 1)  // (angle,x,y,z) angle:旋转角度 (x,y,z):旋转轴
    rotMatrix.translate(0,0.5,0)
    var u_matrix = gl.getUniformLocation(program,"u_matrix")
    gl.uniformMatrix4fv(u_matrix, false, rotMatrix.elements) 

    gl.drawArrays(gl.TRIANGLES, 0, 3)

    let r = 0
    render()
    function render() {
        var rotMatrix = new Matrix4()
        rotMatrix.setRotate(r, 0, 0, 1)  
        
        r++
        var u_matrix = gl.getUniformLocation(program,"u_matrix")
        gl.uniformMatrix4fv(u_matrix, false, rotMatrix.elements)

        gl.clear(gl.COLOR_BUFFER_BIT)
        gl.drawArrays(gl.TRIANGLES, 0, 3)
      
        requestAnimationFrame(render)
    }

    function loadShader(gl, type, source) {
        var shader = gl.createShader(type); // 生成着色器对象
        gl.shaderSource(shader, source); // 载入着色器
        gl.compileShader(shader); // 编译着色器代码
        var compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS); // 判断着色器对象是否生成成功
        return shader;
    }

    function getVSHADER () {
        return `
            attribute vec4 a_Position;
            attribute vec4 a_Color;
            varying vec4 v_Color;

            uniform mat4 u_matrix;
           
            void main(){
                v_Color = a_Color;
                gl_Position = u_matrix*a_Position;
            }
        `
    }

    function getFSHADER () {
        return `
            precision mediump float;
            varying vec4 v_Color;
            void main(){
                gl_FragColor = v_Color;//vec4(1.0, 0.0, 0.0, 1.0);
            }
        `
    }

</script>
</html>