以下是关于纹理的使用和简单说明

```javascript
var texture = gl.createTexture();
// 创建一个纹理对象

gl.activeTexture(gl.TEXTURE0);
// 激活 0 号纹理单元

gl.bindTexture(gl.TEXTURE_2D, texture);
// gl.TEXTURE_2D 是纹理目标
// 将纹理对象 texture 绑定到全局索引对象 gl.TEXTURE_2D 上且 texture 一直是 2D 纹理，不能改变
// 同时，将纹理绑定到 0 号纹理单元

gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
// 将纹理采样的数据上下反转

gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE;
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
// 设置绘制纹理时的参数

gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
// 将图像数据 image 上传到当前 gl.TEXTURE_2D 索引上绑定的纹理对象

gl.generateMipmap(gl.TEXTURE_2D);
// 开启纹理的 minmap

gl.bindTexture(gl.TEXTURE_2D, null)/gl.bindTexture(gl.TEXTURE_CUBE_MAP, null)
gl.deleteTexture(cubeTexture)
// 删除、释放纹理
```

WebGL 有一个纹理单元队列，每个 sampler 全局变量的值对应着一个纹理单元，从对应的单元寻找纹理数据。
在使用 bindTexture 的时候会将纹理绑定到当前活跃纹理单元

```javascript
gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
// 设备支持的纹理单元数量范围

gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
// 查看单元个数

gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
// 查看顶点着色器中可以用几个纹理单元

gl.activeTexture(gl.TEXTURE0);
gl.getParameter(gl.ACTIVE_TEXTURE);
// returns "33984" (0x84C0, gl.TEXUTURE0 enum value)
// 获取当前激活的纹理

gl.TEXTURE0/gl.TEXTURE1/gl.TEXTURE2/gl.TEXTURE3...
```

- OpenGL 提供一组可用的纹理单元，它们可以渲染时同时使用
- glsl 中渲染时，每一个 sampler 采样器都对应一个纹理单元，并从纹理单元中绑定的纹理对象中采样数据
- 采样器代表纹理单元的索引，这也是为什么需要绑定纹理对象到纹理单元
- Shader 可以直接访问所有的纹理单元，它们不关心激活的纹理单元

```javascript
  // 寻找取样器的位置
  var u_image0Location = gl.getUniformLocation(program, "u_image0");
  var u_image1Location = gl.getUniformLocation(program, "u_image1");

  ...
 
  // 设置使用的纹理单元
  gl.uniform1i(u_image0Location, 0);  // 纹理单元 0 将零号纹理单元传递给 u_image0 采样器
  gl.uniform1i(u_image1Location, 1);  // 纹理单元 1

```