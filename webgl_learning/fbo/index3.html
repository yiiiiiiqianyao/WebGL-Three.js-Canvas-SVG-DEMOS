<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <script src="../src/webgl_lib/webgl-utils.js"></script>
    <script src="../src/webgl_lib/webgl-debug.js"></script>
    <script src="../src/webgl_lib/cuon-utils.js"></script>
    <script src="../src/webgl_lib/cuon-matrix.js"></script>
    <script src="../src/utils.js"></script>
    <style>
        #canvas{
            display: block;
            margin: 0 auto;
            border: none;
        }
    </style>
</head>
<body>
    <canvas id="canvas" width="800px" height="800px"></canvas>
</body>
<script>
    var OFFER_SCREEN_WIDTH = 512
    var OFFER_SCREEN_HEIGHT = 512

    // var OFFER_SCREEN_WIDTH = 800
    // var OFFER_SCREEN_HEIGHT = 800

    var canvas = document.getElementById('canvas')
    canvas.width = 800
    canvas.height = 800
    
    // 获取 webgl 绘图上下文
    var gl = getWebGLContext(canvas)
    
    if(!gl) { 
        console.log('not support')
    }

    gl.getExtension('OES_texture_float');
    gl.getExtension('OES_texture_float_linear');

    gl.enable(gl.DEPTH_TEST)
    gl.enable(gl.BLEND) // 开启混合
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA) // 指定混合函数

    var cubeProgram = createProgram(gl, getCubeVSHADER(), getCubeFSHADER()); // 根据说着色器代码构建程序对象
    var rectProgarm = createProgram(gl, getRectVSHADER(), getRectFSHADER())
    

    var viewMatrix = new Matrix4();
    // eyeX, eyeY, eyeZ, centerX, centerY, centerZ, upX, upY, upZ
    viewMatrix.setLookAt(
        3, 3, 7, 
        0, 0, 0, 
        0, 1, 0);
    var projMatrix = new Matrix4();
    projMatrix.setPerspective(30, canvas.width/canvas.height, 1, 100);
    let modelMatrix = new Matrix4()
    modelMatrix.rotate(-90, 0, 1, 0)

    var modeViewProjMatrix = projMatrix.clone().multiply(viewMatrix.clone().multiply(modelMatrix.clone()));

    
    // draw cube(fbo)

    // var fbo = initFrameBufferObject(gl)
   
    // gl.viewport(0, 0, OFFER_SCREEN_WIDTH, OFFER_SCREEN_HEIGHT)
    // gl.clearColor(0.0, 0.0, 0.0, 0.0)
    // gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT)
   
    gl.useProgram(cubeProgram); // 上下文对象绑定程序对象
    var u_ModelViewMatrix = bindUnifrom4fv('u_ModelViewMatrix', modeViewProjMatrix.elements, cubeProgram)
    
    var { buffer: buffer1, attr: attr1 } = bindAttriBuffer('a_Position', CubeVertices, 3, cubeProgram)

    var { buffer: buffer3, attr: attr3 } = bindAttriBuffer('a_Color', CubeColors, 3, cubeProgram)

    // bindTexture0("../src/images/i.jpg", 'u_Sampler', cubeProgram)

    var { indexBuffer, indices } = bindElementBuffer(cubeIndices)

    // gl.bindFramebuffer(gl.FRAMEBUFFER, fbo)
    gl.drawElements(gl.TRIANGLES, cubeIndices.length, gl.UNSIGNED_BYTE, 0);
    
    // gl.bindFramebuffer(gl.FRAMEBUFFER, null)
    // draw cube(fbo)


    // draw rect

    var dynamicTexture = createDynamicTexture()
    gl.bindTexture(gl.TEXTURE_2D, dynamicTexture)
    gl.copyTexImage2D(gl.TEXTURE_2D, 0, gl.RGB, 0, 0, 512.0, 512.0, 0);
    // gl.copyTexSubImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 0, 0, 128, 128, 0);
    // gl.copyTexImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 0, 0, 512, 512, 0);
    // gl.viewport(0, 0, canvas.width, canvas.height)
    // gl.clearColor(0.6, 0.6, 0.6, 1.0) // 指定清空 canvas 的颜色 (背景色)
    // gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT)

    gl.useProgram(rectProgarm); // 上下文对象绑定程序对象
    var { buffer: buffer4, attr: attr4 } = bindAttriBuffer('a_rectPosition', rectVertices, 2, rectProgarm)
    var { buffer: buffer5, attr: attr5 } = bindAttriBuffer('a_TextCoord', rectUvs, 2, rectProgarm)
    bindDynamicTexture(dynamicTexture, "u_Sampler", rectProgarm)
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4); 
    
    // draw rect

    animate()
    function animate() {
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT)

        // draw cube(fbo)
        gl.useProgram(cubeProgram); 

        modelMatrix.rotate(-1, 0, 1, 0)
        var modeViewMatrix = projMatrix.clone().multiply(viewMatrix.clone().multiply(modelMatrix));
        gl.uniformMatrix4fv(u_ModelViewMatrix, false, modeViewMatrix.elements);

        gl.bindBuffer(gl.ARRAY_BUFFER, buffer1)
        gl.vertexAttribPointer(attr1, 3, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, buffer3)
        gl.vertexAttribPointer(attr3, 3, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer)

        gl.drawElements(gl.TRIANGLES, cubeIndices.length, gl.UNSIGNED_BYTE, 0);
        // draw cube(fbo)

        // draw rect

        gl.useProgram(rectProgarm); 

        var dynamicTexture = createDynamicTexture()
        gl.bindTexture(gl.TEXTURE_2D, dynamicTexture)
        // gl.copyTexImage2D(gl.TEXTURE_2D, 0, gl.RGB, 0, 0, 512.0, 512.0, 0);
        gl.copyTexImage2D(gl.TEXTURE_2D, 0, gl.RGB, 0, 0, 512.0, 512.0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, buffer4)
        gl.vertexAttribPointer(attr4, 2, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, buffer5)
        gl.vertexAttribPointer(attr5, 2, gl.FLOAT, false, 0, 0);
        
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        gl.bindTexture(gl.TEXTURE_2D, null)

        // draw rect

        requestAnimationFrame(animate)
    }

    function bindAttriBuffer(attrName, vertices, count, program) {
        let buffer = gl.createBuffer()
        if(!buffer) {
            console.log("failed create vertex buffer")
        }
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer) // 将缓冲区对象绑定到目标
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW) // 向缓冲区对象中写入数据

        let attr = gl.getAttribLocation(program, attrName);
        gl.vertexAttribPointer(attr, count, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(attr);
        return { buffer, attr }
    }

    function bindUnifrom4fv(unifromName, data, program) {
        let uniform4f = gl.getUniformLocation(program, unifromName);
        if (uniform4f < 0) {
            console.log("无法获取矩阵变量的存储位置");
        }
        gl.uniformMatrix4fv(uniform4f, false, data);
        return uniform4f
    }

    function bindElementBuffer(indices) {
        let indexBuffer = gl.createBuffer();
        if (!indexBuffer) {
            console.log("无法创建缓冲区对象");
        }
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);
        return { indexBuffer, indices }
    }

    function getCubeVSHADER() {
        return `
            attribute vec4 a_Position;
            attribute vec3 a_Color;
            // attribute vec2 a_Uv;
            uniform mat4 u_ModelViewMatrix;
            // varying vec2 v_Uv;
            varying vec3 v_Color;
            void main(){
                gl_Position = u_ModelViewMatrix * a_Position;
                // v_Uv = a_Uv;
                v_Color = a_Color;
            }
        `
    }

    function getCubeFSHADER() {
        return `
            #ifdef GL_ES
            precision mediump float;
            #endif
            // varying vec2 v_Uv;
            // uniform sampler2D u_Sampler;
            varying vec3 v_Color;
            void main(){
                // gl_FragColor = texture2D(u_Sampler, v_Uv);
                gl_FragColor = vec4(v_Color, 1.0);
            }
        `
    }

    function getRectVSHADER(){
        return `
            attribute vec4 a_rectPosition;
            attribute vec2 a_TextCoord;
            varying vec2 v_TexCoord;

            void main(){
                gl_Position = a_rectPosition;
                // gl_Position = vec4(0.0, 0.0, 0.0, 1.0);
                // gl_PointSize = 10.0;
                v_TexCoord = a_TextCoord;
            }
        `
    }

    function getRectFSHADER(){
        return `
            precision mediump float;

            uniform sampler2D u_Sampler;
            varying vec2 v_TexCoord;

            void main(){
                // gl_FragColor = texture2D(u_Sampler, v_TexCoord);
                vec4 diff = texture2D(u_Sampler, v_TexCoord);
                // R×0.299+G×0.587+B×0.114
                float gray = diff.r * 0.299 + diff.g * 0.587 + diff.b * 0.114;
                gl_FragColor = vec4(vec3(gray), 1.0);
                // if(length(gl_FragColor.xyz) == 0.0)  gl_FragColor.w = 0.0;
                // gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
            }
        `
    }

    function handleLoadedTexture(texture) {
        gl.bindTexture(gl.TEXTURE_2D, texture) // 绑定当前的纹理单元（设置纹理单元的参数是针对每张不同纹理， 而不是同时作用与所有的纹理单元）
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1) // 对纹理图像进行 Y 轴反转 - 点精灵不需要翻转

        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR); 
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.image);

    }

    function initTexture(imageFile, callback) {
        let texture = gl.createTexture()
        texture.image = new Image()
        texture.image.src = imageFile
        texture.image.onload = () => {
            handleLoadedTexture(texture)
            callback(texture)
        }
    }

    function bindFBOTexture(texture, samplerName, program) {
        gl.bindTexture(gl.TEXTURE_2D, texture) // 绑定当前的纹理单元（设置纹理单元的参数是针对每张不同纹理， 而不是同时作用与所有的纹理单元）
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1) // 对纹理图像进行 Y 轴反转 - 点精灵不需要翻转

        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR); 
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

        // 此时的 texture 不能被写入
        // gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture);
        

        gl.activeTexture(gl.TEXTURE0); // 激活0号纹理单元
        var u_Sampler = gl.getUniformLocation(program, samplerName);
        gl.uniform1i(u_Sampler, 0);
    }

    function bindDynamicTexture(texture, samplerName, program) {
        gl.bindTexture(gl.TEXTURE_2D, texture) // 绑定当前的纹理单元（设置纹理单元的参数是针对每张不同纹理， 而不是同时作用与所有的纹理单元）
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1) // 对纹理图像进行 Y 轴反转 - 点精灵不需要翻转

        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR); 
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

        // 此时的 texture 不能被写入
        // gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture)

        // gl.activeTexture(gl.TEXTURE0); // 激活0号纹理单元
        var u_Sampler = gl.getUniformLocation(program, samplerName);
        gl.uniform1i(u_Sampler, 0);
    }

    function bindTexture0(textureName, samplerName, program) {
        initTexture(textureName, function(texture) {
            gl.activeTexture(gl.TEXTURE0); // 激活0号纹理单元
            gl.bindTexture(gl.TEXTURE_2D, texture); // 绑定纹理单元

            var u_Sampler = gl.getUniformLocation(program, samplerName);
            gl.uniform1i(u_Sampler, 0);
        })
      
    }

    function bindTexture1(textureName, samplerName, program) {
        var texture = initTexture(textureName)
        gl.activeTexture(gl.TEXTURE1); // 激活0号纹理单元
        gl.bindTexture(gl.TEXTURE_2D, texture); // 绑定纹理单元

        var u_Sampler = gl.getUniformLocation(program, samplerName);
        gl.uniform1i(u_Sampler, 0);
    }

    function createDynamicTexture() {
        var texture = gl.createTexture()
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, texture)

        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, OFFER_SCREEN_WIDTH, OFFER_SCREEN_HEIGHT, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);

        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR); 
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR); 
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

        return texture
    }

    function initFrameBufferObject(gl) {
        var frameBuffer = gl.createFramebuffer()

        var texture = gl.createTexture()
        gl.bindTexture(gl.TEXTURE_2D, texture)
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, OFFER_SCREEN_WIDTH, OFFER_SCREEN_HEIGHT, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR)

        frameBuffer.texture = texture

       // 新建渲染缓冲区对象作为帧缓冲区的深度缓冲区对象
        var depthBuffer = gl.createRenderbuffer();
        gl.bindRenderbuffer(gl.RENDERBUFFER, depthBuffer);
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, OFFER_SCREEN_WIDTH, OFFER_SCREEN_HEIGHT);

        gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, depthBuffer);

        var e = gl.checkFramebufferStatus(gl.FRAMEBUFFER)
        if(e != gl.FRAMEBUFFER_COMPLETE) {
            console.log('err', e.toString())
        }
        
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.bindTexture(gl.TEXTURE_2D, null);
        gl.bindRenderbuffer(gl.RENDERBUFFER, null);
        
        return frameBuffer
    }

</script>
</html>