<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <script src="../src/webgl_lib/webgl-utils.js"></script>
    <script src="../src/webgl_lib/webgl-debug.js"></script>
    <script src="../src/webgl_lib/cuon-utils.js"></script>
    <script src="../src/webgl_lib/cuon-matrix.js"></script>
    <script src="../src/utils.js"></script>
    <style>
        #canvas{
            display: block;
            margin: 0 auto;
            border: none;
        }
    </style>
</head>
<body>
    <canvas id="canvas" width="800px" height="800px"></canvas>
</body>
<script>
    var imageLoaded = false
    var canvas = document.getElementById('canvas')
    canvas.width = 800
    canvas.height = 800
    
    // 获取 webgl 绘图上下文
    var gl = getWebGLContext(canvas)
    if(!gl) { 
        console.log('not support')
    }

    var viewMatrix = new Matrix4();
    // eyeX, eyeY, eyeZ, centerX, centerY, centerZ, upX, upY, upZ
    viewMatrix.setLookAt(
        3, 3, 7, 
        0, 0, 0, 
        0, 1, 0);
    // let distance = Math.sqrt((3-0)*(3-0))

    //设置透视投影矩阵
    var projMatrix = new Matrix4();
    projMatrix.setPerspective(30, canvas.width/canvas.height, 1, 100);
    
    //设置模型矩阵的相关信息
    let modelMatrix = new Matrix4()
    modelMatrix.rotate(-90, 0, 1, 0)

    var modeViewProjMatrix = projMatrix.clone().multiply(viewMatrix.clone().multiply(modelMatrix.clone()));

    var vertexShader = getCubeVSHADER()
    var fragmentShader = getCubeFSHADER()
    // 初始化着色器
    if(!initShaders(gl, vertexShader, fragmentShader)){   // initShaders => true : 创建成功, false : 创建失败
        console.log('failed initShader')
    }

    gl.clearColor(0.6, 0.6, 0.6, 1.0) // 指定清空 canvas 的颜色 (背景色)
    gl.enable(gl.DEPTH_TEST)
    // gl.enable(gl.CULL_FACE) // 开启背面剔除
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT)
    gl.enable(gl.BLEND) // 开启混合
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA) // 指定混合函数


    var u_ModelViewMatrix = bindUnifrom4fv('u_ModelViewMatrix', modeViewProjMatrix.elements)
    bindElementBuffer(cubeIndices)
    bindAttriBuffer('a_Position', CubeVertices, 3)
    // bindAttriBuffer('a_Color', CubeColors, 3)
    bindAttriBuffer('a_Uv', CubeUvs, 2)

    let texture = gl.createTexture()
    let image = new Image()
    image.src = "../src/images/i.jpg"
    image.onload = () => {
        gl.bindTexture(gl.TEXTURE_2D, texture) // 绑定当前的纹理单元（设置纹理单元的参数是针对每张不同纹理， 而不是同时作用与所有的纹理单元）
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1) // 对纹理图像进行 Y 轴反转 - 点精灵不需要翻转

        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR); 
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);

        var u_Sampler = gl.getUniformLocation(gl.program, 'u_Sampler');
        gl.uniform1i(u_Sampler, 0);

        gl.drawElements(gl.TRIANGLES, cubeIndices.length, gl.UNSIGNED_BYTE, 0);
    }

    gl.drawElements(gl.TRIANGLES, cubeIndices.length, gl.UNSIGNED_BYTE, 0);
    // animate()
    
    function animate() {

        gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);
     
        if(imageLoaded) {
            modelMatrix.rotate(-1, 0, 1, 0)

            var modeViewMatrix = projMatrix.clone().multiply(viewMatrix.clone().multiply(modelMatrix));
            gl.uniformMatrix4fv(u_ModelViewMatrix, false, modeViewMatrix.elements);

            gl.drawElements(gl.TRIANGLES, cubeIndices.length, gl.UNSIGNED_BYTE, 0);
        }
      
        requestAnimationFrame(animate)
    }

    function bindAttriBuffer(attrName, vertices, count) {
        let vertexBuffer = gl.createBuffer()
        if(!vertexBuffer) {
            console.log("failed create vertex buffer")
        }
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer, count) // 将缓冲区对象绑定到目标
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW) // 向缓冲区对象中写入数据

        var attr = gl.getAttribLocation(gl.program, attrName);
        gl.vertexAttribPointer(attr, count, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(attr);
    }

    function bindUnifrom4fv(unifromName, data) {
        var uniform4f = gl.getUniformLocation(gl.program, unifromName);
        if (uniform4f < 0) {
            console.log("无法获取矩阵变量的存储位置");
        }

        gl.uniformMatrix4fv(uniform4f, false, data);
        return uniform4f
    }

    function bindElementBuffer(indices) {
        var indexBuffer = gl.createBuffer();
        if (!indexBuffer) {
            console.log("无法创建缓冲区对象");
        }
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);
    }

    function getCubeVSHADER() {
        return `
            attribute vec4 a_Position;
            attribute vec4 a_Color;
            attribute vec2 a_Uv;
            uniform mat4 u_ModelViewMatrix;
            varying vec4 v_Color;
            varying vec2 v_Uv;
            void main(){
                gl_Position = u_ModelViewMatrix * a_Position;
                v_Color = a_Color;
                v_Uv = a_Uv;
            }
        `
    }

    function getCubeFSHADER() {
        return `
            #ifdef GL_ES
            precision mediump float;
            #endif
            varying vec4 v_Color;
            varying vec2 v_Uv;
            uniform sampler2D u_Sampler;
            void main(){
                // gl_FragColor = v_Color;
                gl_FragColor = texture2D(u_Sampler, v_Uv);
                // gl_FragColor.a = v_Uv.y;
            }
        `
    }

    function handleLoadedTexture(texture) {
       

    }

    function initTexture(imageFile) {
       
    }

    function bindTexture(textureName, samplerName, program) {
   
        let texture = gl.createTexture()
        let image = new Image()
        image.src = textureName
        image.onload = () => {
            gl.bindTexture(gl.TEXTURE_2D, texture) // 绑定当前的纹理单元（设置纹理单元的参数是针对每张不同纹理， 而不是同时作用与所有的纹理单元）
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1) // 对纹理图像进行 Y 轴反转 - 点精灵不需要翻转

            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR); 
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);

            gl.drawElements(gl.TRIANGLES, cubeIndices.length, gl.UNSIGNED_BYTE, 0);
        }
    }

    
</script>
</html>