<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <link rel="shortcut icon" href="../favicon.ico" />
    <link rel="bookmark" href="../favicon.ico" />
    <title>Document</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
    </style>
    <script src="../src/three.js"></script>
    <script src="../src/controller/OrbitControls.js"></script>
    <script src="../src/libs/stats.min.js"></script>
  </head>
  <body></body>

 <!-- https://codepen.io/alphardex/pen/OJmPpeJ -->
  <script type="module">
    var scene, camera, renderer, clock, controller, stats
    var shader_material, rayMarchingFireMaterial, shaderMaterial
    const rayMarchingFireVertexShader = `
varying vec2 vUv;
varying vec3 vPosition;

void main(){
    vec4 modelPosition=modelMatrix*vec4(position,1.);
    vec4 viewPosition=viewMatrix*modelPosition;
    vec4 projectedPosition=projectionMatrix*viewPosition;
    gl_Position=projectedPosition;
    
    vUv=uv;
    vPosition=position;
}
`;

    const rayMarchingFireFragmentShader = `
      #define GLSLIFY 1
      vec2 centerUv(vec2 uv,vec2 resolution){
          uv=2.*uv-1.;
          float aspect=resolution.x/resolution.y;
          uv.x*=aspect;
          return uv;
      }

      mat3 setCamera(in vec3 ro,in vec3 ta,float cr)
      {
          vec3 cw=normalize(ta-ro);
          vec3 cp=vec3(sin(cr),cos(cr),0.);
          vec3 cu=normalize(cross(cw,cp));
          vec3 cv=(cross(cu,cw));
          return mat3(cu,cv,cw);
      }

      vec3 getRayDirection(vec2 p,vec3 ro,vec3 ta,float fl){
          mat3 ca=setCamera(ro,ta,0.);
          vec3 rd=ca*normalize(vec3(p,fl));
          return rd;
      }

      float sdSphere( vec3 p, float s )
      {
        return length( p ) - s;
      }

      float opU( float d1, float d2 )
      {
          return min(d1,d2);
      }

      vec2 opU( vec2 d1, vec2 d2 ){
        return ( d1.x < d2.x ) ? d1 : d2;
      }

      //
      // GLSL textureless classic 3D noise "cnoise",
      // with an RSL-style periodic variant "pnoise".
      // Author:  Stefan Gustavson (stefan.gustavson@liu.se)
      // Version: 2011-10-11
      //
      // Many thanks to Ian McEwan of Ashima Arts for the
      // ideas for permutation and gradient selection.
      //
      // Copyright (c) 2011 Stefan Gustavson. All rights reserved.
      // Distributed under the MIT license. See LICENSE file.
      // https://github.com/ashima/webgl-noise
      //

      vec3 mod289(vec3 x)
      {
        return x - floor(x * (1.0 / 289.0)) * 289.0;
      }

      vec4 mod289(vec4 x)
      {
        return x - floor(x * (1.0 / 289.0)) * 289.0;
      }

      vec4 permute(vec4 x)
      {
        return mod289(((x*34.0)+1.0)*x);
      }

      vec4 taylorInvSqrt(vec4 r)
      {
        return 1.79284291400159 - 0.85373472095314 * r;
      }

      vec3 fade(vec3 t) {
        return t*t*t*(t*(t*6.0-15.0)+10.0);
      }

      // Classic Perlin noise
      float cnoise(vec3 P)
      {
        vec3 Pi0 = floor(P); // Integer part for indexing
        vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1
        Pi0 = mod289(Pi0);
        Pi1 = mod289(Pi1);
        vec3 Pf0 = fract(P); // Fractional part for interpolation
        vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0
        vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
        vec4 iy = vec4(Pi0.yy, Pi1.yy);
        vec4 iz0 = Pi0.zzzz;
        vec4 iz1 = Pi1.zzzz;

        vec4 ixy = permute(permute(ix) + iy);
        vec4 ixy0 = permute(ixy + iz0);
        vec4 ixy1 = permute(ixy + iz1);

        vec4 gx0 = ixy0 * (1.0 / 7.0);
        vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
        gx0 = fract(gx0);
        vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
        vec4 sz0 = step(gz0, vec4(0.0));
        gx0 -= sz0 * (step(0.0, gx0) - 0.5);
        gy0 -= sz0 * (step(0.0, gy0) - 0.5);

        vec4 gx1 = ixy1 * (1.0 / 7.0);
        vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
        gx1 = fract(gx1);
        vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
        vec4 sz1 = step(gz1, vec4(0.0));
        gx1 -= sz1 * (step(0.0, gx1) - 0.5);
        gy1 -= sz1 * (step(0.0, gy1) - 0.5);

        vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
        vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
        vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
        vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
        vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
        vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
        vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
        vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);

        vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
        g000 *= norm0.x;
        g010 *= norm0.y;
        g100 *= norm0.z;
        g110 *= norm0.w;
        vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
        g001 *= norm1.x;
        g011 *= norm1.y;
        g101 *= norm1.z;
        g111 *= norm1.w;

        float n000 = dot(g000, Pf0);
        float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
        float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
        float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
        float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
        float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
        float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
        float n111 = dot(g111, Pf1);

        vec3 fade_xyz = fade(Pf0);
        vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
        vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
        float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);
        return 2.2 * n_xyz;
      }

      uniform float uTime;
      uniform vec2 uMouse;
      uniform vec2 uResolution;
      uniform float uVelocity;
      uniform vec3 uColor1;
      uniform vec3 uColor2;

      varying vec2 vUv;
      varying vec3 vPosition;

      float fire(vec3 p){
          vec3 p2=p*vec3(1.,.5,1.)+vec3(0.,1.,0.);
          float geo=sdSphere(p2,1.);
          // float result=geo;
          float displacement=uTime*uVelocity;
          vec3 displacementY=vec3(.0,displacement,.0);
          float noise=(cnoise(p+displacementY))*p.y*.4;
          float result=geo+noise;
          return result;
      }

      vec2 sdf(vec3 p){
          float result=opU(abs(fire(p)),-(length(p)-100.));
          float objType=1.;
          return vec2(result,objType);
      }

      vec4 rayMarch(vec3 eye,vec3 ray){
          float depth=0.;
          float strength=0.;
          float eps=.02;
          vec3 pos=eye;
          for(int i=0;i<64;i++){
              pos+=depth*ray;
              float dist=sdf(pos).x;
              depth=dist+eps;
              if(dist>0.){
                  strength=float(i)/64.;
              }
          }
          return vec4(pos,strength);
      }

      void main(){
          vec2 p=centerUv(vUv,uResolution);
          p=p*vec2(1.6,-1);
          
          vec3 ro=vec3(0.,-2.,4.);
          vec3 ta=vec3(0.,-2.5,-1.5);
          float fl=1.25;
          vec3 rd=getRayDirection(p,ro,ta,fl);
          
          vec3 color=vec3(0.);
          
          vec4 result=rayMarch(ro,rd);
          
          float strength=pow(result.w*2.,4.);
          vec3 ellipse=vec3(strength);
          color=ellipse;
          
          float fireBody=result.y/64.;
          vec3 mixColor=mix(uColor1,uColor2,fireBody);
          color*=mixColor;
          
          // Y = 0.299R + 0.587G + 0.114B // 亮度提取
          // float alpha = 0.299 * color.r + 0.587 * color.g + 0.114 * color.b;

          // gl_FragColor=vec4(color, alpha);
          gl_FragColor=vec4(color, 1.);
      }
      `

    init();
    animate();

    // - Functions -
    function init() {
      scene = new THREE.Scene();
      clock = new THREE.Clock();
      camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.set(10, 10, 10)
      renderer = new THREE.WebGLRenderer({
        antialias: true, // 开启抗锯齿处理
        alpha: true,
      });
      renderer.setClearColor(0xbfd1e5) // set sky color
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio)
      // renderer.shadowMap.enabled = true

      createRayMarchingFireMaterial();

      var axisHelper = new THREE.AxesHelper(10);
      scene.add(axisHelper);
     
      var directionalLight = new THREE.DirectionalLight(0xffffff, 0.9);
      directionalLight.position.set(400, 200, 300);
      // directionalLight.castShadow = true
      scene.add(directionalLight);
      // 方向光2
      var directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.9);
      directionalLight2.position.set(-400, -200, -300);
      scene.add(directionalLight2);
      //环境光
      var ambient = new THREE.AmbientLight(0x404040, 0.6);
      scene.add(ambient);

      stats = new Stats()
      document.body.appendChild( stats.dom );

      // --------
      var geometry = new THREE.PlaneBufferGeometry( 5, 5);
      var material = new THREE.MeshPhongMaterial( {color: 0x00ff00} );
      var cube = new THREE.Mesh( geometry, rayMarchingFireMaterial );
      scene.add( cube );
      // --------

      controller = new THREE.OrbitControls(camera, renderer.domElement);
      document.body.appendChild(renderer.domElement);
      window.onresize = onResize;
    }

    function createRayMarchingFireMaterial() {
      rayMarchingFireMaterial = new THREE.ShaderMaterial({
        transparent: true,
        vertexShader: rayMarchingFireVertexShader,
        fragmentShader: rayMarchingFireFragmentShader,
        side: THREE.DoubleSide,
        uniforms: {
          uTime: {
            value: 0,
          },
          uMouse: {
            value: new THREE.Vector2(0, 0),
          },
          uResolution: {
            // value: new THREE.Vector2(window.innerWidth, window.innerHeight),
            value: new THREE.Vector2(512, 512)
          },
          uVelocity: {
            value: 3,
          },
          uColor1: {
            value: new THREE.Color('#ff801a'),
          },
          uColor2: {
            value: new THREE.Color('#ff5718'),
          },
        },
      });
      shaderMaterial = rayMarchingFireMaterial;
  }

    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
      stats.update();
      controller.update(clock.getDelta());

      if(rayMarchingFireMaterial) {
        rayMarchingFireMaterial.uniforms.uTime.value += 0.01
      }
    }

    function onResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
  </script>
</html>
